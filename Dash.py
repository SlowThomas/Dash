'''
NOTES:

DEFAULT UNITS:
length: pixel
time: s
speed: pixel/s
acceleration: pixel/s^2


FORMATTING:

matrix => [row][col]
[
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0]
]
vector => [row][0]
[
    [0],
    [0],
    [0],
    [0]
]
face => [vertex(vector) #]
[
    vector,
    vector,
    vector
]
mesh => [face #]
[
    face,
    face,
    ...
    face
]

CALCULATIONS:

rotate a function => x' = x cos(θ) - y sin(θ)
                     y' = x sin(θ) + y cos(θ)

coordinates - real position vector:
[
    [x],
    [y],
    [z],
    [1]
]

coordinates - real relation vector:
[
    [x],
    [y],
    [z],
    [0]
]

coordinates - visual position vector for Perspective Projection:
[
    [x],
    [y],
    [z],
    [w]
]

visual position vector's location on screen:
(x / w, y / w)
'''

from graphics import *
import random
import sys

FPS = 30
SPF = 1/FPS
WIDTH = 1300
HEIGHT = 800
π = 3.1415926535857
e = 2.7182818284590

screen_distance = 0.5 * 5000
VIEW_VOL = [WIDTH*2 / 2 + 100, HEIGHT*2 / 2 + 100, 500000]

factorial_calc = [1, 1]

def set_screen_dis(x):
    global screen_distance
    screen_distance = x

def get_screen_dis():
    global screen_distance
    return screen_distance

def factorial(x):
    global factorial_calc
    if(len(factorial_calc) > x):
        return factorial_calc[x]
    result = 1
    factorial_calc[0] = 1
    for i in range(1, x + 1):
        result *= i
        try:
            factorial_calc[i] = result
        except IndexError:
            factorial_calc.append(result)
    return result

def sin(x):#, precision=100):
    return 0+0*(x ** 0) / 1+1*(x ** 1) / 1+0*(x ** 2) / 2+-1*(x ** 3) / 6+0*(x ** 4) / 24+1*(x ** 5) / 120+0*(x ** 6) / 720+-1*(x ** 7) / 5040+0*(x ** 8) / 40320+1*(x ** 9) / 362880+0*(x ** 10) / 3628800+-1*(x ** 11) / 39916800+0*(x ** 12) / 479001600+1*(x ** 13) / 6227020800+0*(x ** 14) / 87178291200+-1*(x ** 15) / 1307674368000+0*(x ** 16) / 20922789888000+1*(x ** 17) / 355687428096000+0*(x ** 18) / 6402373705728000+-1*(x ** 19) / 121645100408832000+0*(x ** 20) / 2432902008176640000+1*(x ** 21) / 51090942171709440000+0*(x ** 22) / 1124000727777607680000+-1*(x ** 23) / 25852016738884976640000+0*(x ** 24) / 620448401733239439360000+1*(x ** 25) / 15511210043330985984000000+0*(x ** 26) / 403291461126605635584000000+-1*(x ** 27) / 10888869450418352160768000000+0*(x ** 28) / 304888344611713860501504000000+1*(x ** 29) / 8841761993739701954543616000000+0*(x ** 30) / 265252859812191058636308480000000+-1*(x ** 31) / 8222838654177922817725562880000000+0*(x ** 32) / 263130836933693530167218012160000000+1*(x ** 33) / 8683317618811886495518194401280000000+0*(x ** 34) / 295232799039604140847618609643520000000+-1*(x ** 35) / 10333147966386144929666651337523200000000+0*(x ** 36) / 371993326789901217467999448150835200000000+1*(x ** 37) / 13763753091226345046315979581580902400000000+0*(x ** 38) / 523022617466601111760007224100074291200000000+-1*(x ** 39) / 20397882081197443358640281739902897356800000000+0*(x ** 40) / 815915283247897734345611269596115894272000000000+1*(x ** 41) / 33452526613163807108170062053440751665152000000000+0*(x ** 42) / 1405006117752879898543142606244511569936384000000000+-1*(x ** 43) / 60415263063373835637355132068513997507264512000000000+0*(x ** 44) / 2658271574788448768043625811014615890319638528000000000+1*(x ** 45) / 119622220865480194561963161495657715064383733760000000000+0*(x ** 46) / 5502622159812088949850305428800254892961651752960000000000+-1*(x ** 47) / 258623241511168180642964355153611979969197632389120000000000+0*(x ** 48) / 12413915592536072670862289047373375038521486354677760000000000+1*(x ** 49) / 608281864034267560872252163321295376887552831379210240000000000+0*(x ** 50) / 30414093201713378043612608166064768844377641568960512000000000000+-1*(x ** 51) / 1551118753287382280224243016469303211063259720016986112000000000000+0*(x ** 52) / 80658175170943878571660636856403766975289505440883277824000000000000+1*(x ** 53) / 4274883284060025564298013753389399649690343788366813724672000000000000+0*(x ** 54) / 230843697339241380472092742683027581083278564571807941132288000000000000+-1*(x ** 55) / 12696403353658275925965100847566516959580321051449436762275840000000000000+0*(x ** 56) / 710998587804863451854045647463724949736497978881168458687447040000000000000+1*(x ** 57) / 40526919504877216755680601905432322134980384796226602145184481280000000000000+0*(x ** 58) / 2350561331282878571829474910515074683828862318181142924420699914240000000000000+-1*(x ** 59) / 138683118545689835737939019720389406345902876772687432540821294940160000000000000+0*(x ** 60) / 8320987112741390144276341183223364380754172606361245952449277696409600000000000000+1*(x ** 61) / 507580213877224798800856812176625227226004528988036003099405939480985600000000000000+0*(x ** 62) / 31469973260387937525653122354950764088012280797258232192163168247821107200000000000000+-1*(x ** 63) / 1982608315404440064116146708361898137544773690227268628106279599612729753600000000000000+0*(x ** 64) / 126886932185884164103433389335161480802865516174545192198801894375214704230400000000000000+1*(x ** 65) / 8247650592082470666723170306785496252186258551345437492922123134388955774976000000000000000+0*(x ** 66) / 544344939077443064003729240247842752644293064388798874532860126869671081148416000000000000000+-1*(x ** 67) / 36471110918188685288249859096605464427167635314049524593701628500267962436943872000000000000000+0*(x ** 68) / 2480035542436830599600990418569171581047399201355367672371710738018221445712183296000000000000000+1*(x ** 69) / 171122452428141311372468338881272839092270544893520369393648040923257279754140647424000000000000000+0*(x ** 70) / 11978571669969891796072783721689098736458938142546425857555362864628009582789845319680000000000000000+-1*(x ** 71) / 850478588567862317521167644239926010288584608120796235886430763388588680378079017697280000000000000000+0*(x ** 72) / 61234458376886086861524070385274672740778091784697328983823014963978384987221689274204160000000000000000+1*(x ** 73) / 4470115461512684340891257138125051110076800700282905015819080092370422104067183317016903680000000000000000+0*(x ** 74) / 330788544151938641225953028221253782145683251820934971170611926835411235700971565459250872320000000000000000+-1*(x ** 75) / 24809140811395398091946477116594033660926243886570122837795894512655842677572867409443815424000000000000000000+0*(x ** 76) / 1885494701666050254987932260861146558230394535379329335672487982961844043495537923117729972224000000000000000000+1*(x ** 77) / 145183092028285869634070784086308284983740379224208358846781574688061991349156420080065207861248000000000000000000+0*(x ** 78) / 11324281178206297831457521158732046228731749579488251990048962825668835325234200766245086213177344000000000000000000+-1*(x ** 79) / 894618213078297528685144171539831652069808216779571907213868063227837990693501860533361810841010176000000000000000000+0*(x ** 80) / 71569457046263802294811533723186532165584657342365752577109445058227039255480148842668944867280814080000000000000000000+1*(x ** 81) / 5797126020747367985879734231578109105412357244731625958745865049716390179693892056256184534249745940480000000000000000000+0*(x ** 82) / 475364333701284174842138206989404946643813294067993328617160934076743994734899148613007131808479167119360000000000000000000+-1*(x ** 83) / 39455239697206586511897471180120610571436503407643446275224357528369751562996629334879591940103770870906880000000000000000000+0*(x ** 84) / 3314240134565353266999387579130131288000666286242049487118846032383059131291716864129885722968716753156177920000000000000000000+1*(x ** 85) / 281710411438055027694947944226061159480056634330574206405101912752560026159795933451040286452340924018275123200000000000000000000+0*(x ** 86) / 24227095383672732381765523203441259715284870552429381750838764496720162249742450276789464634901319465571660595200000000000000000000+-1*(x ** 87) / 2107757298379527717213600518699389595229783738061356212322972511214654115727593174080683423236414793504734471782400000000000000000000+0*(x ** 88) / 185482642257398439114796845645546284380220968949399346684421580986889562184028199319100141244804501828416633516851200000000000000000000+1*(x ** 89) / 16507955160908461081216919262453619309839666236496541854913520707833171034378509739399912570787600662729080382999756800000000000000000000+0*(x ** 90) / 1485715964481761497309522733620825737885569961284688766942216863704985393094065876545992131370884059645617234469978112000000000000000000000+-1*(x ** 91) / 135200152767840296255166568759495142147586866476906677791741734597153670771559994765685283954750449427751168336768008192000000000000000000000+0*(x ** 92) / 12438414054641307255475324325873553077577991715875414356840239582938137710983519518443046123837041347353107486982656753664000000000000000000000+1*(x ** 93) / 1156772507081641574759205162306240436214753229576413535186142281213246807121467315215203289516844845303838996289387078090752000000000000000000000+0*(x ** 94) / 108736615665674308027365285256786601004186803580182872307497374434045199869417927630229109214583415458560865651202385340530688000000000000000000000+-1*(x ** 95) / 10329978488239059262599702099394727095397746340117372869212250571234293987594703124871765375385424468563282236864226607350415360000000000000000000000+0*(x ** 96) / 991677934870949689209571401541893801158183648651267795444376054838492222809091499987689476037000748982075094738965754305639874560000000000000000000000+1*(x ** 97) / 96192759682482119853328425949563698712343813919172976158104477319333745612481875498805879175589072651261284189679678167647067832320000000000000000000000+0*(x ** 98) / 9426890448883247745626185743057242473809693764078951663494238777294707070023223798882976159207729119823605850588608460429412647567360000000000000000000000+-1*(x ** 99) / 933262154439441526816992388562667004907159682643816214685929638952175999932299156089414639761565182862536979208272237582511852109168640000000000000000000000
    ## original code
    if x >= 0:
        x = x % (2*π)
    else:
        x = -((-x) %(2*π))
    result = 0
    sequence = [0, -1, 0, 1]
    for i in range(precision):
        result += sequence[i % 4] * (x ** i) / factorial(i)
    if result < -1:
        result = -1
    if result > 1:
        result = 1
    return result


def cos(x):#, precision=100):
    return 0+1*(x ** 0) / 1+0*(x ** 1) / 1+-1*(x ** 2) / 2+0*(x ** 3) / 6+1*(x ** 4) / 24+0*(x ** 5) / 120+-1*(x ** 6) / 720+0*(x ** 7) / 5040+1*(x ** 8) / 40320+0*(x ** 9) / 362880+-1*(x ** 10) / 3628800+0*(x ** 11) / 39916800+1*(x ** 12) / 479001600+0*(x ** 13) / 6227020800+-1*(x ** 14) / 87178291200+0*(x ** 15) / 1307674368000+1*(x ** 16) / 20922789888000+0*(x ** 17) / 355687428096000+-1*(x ** 18) / 6402373705728000+0*(x ** 19) / 121645100408832000+1*(x ** 20) / 2432902008176640000+0*(x ** 21) / 51090942171709440000+-1*(x ** 22) / 1124000727777607680000+0*(x ** 23) / 25852016738884976640000+1*(x ** 24) / 620448401733239439360000+0*(x ** 25) / 15511210043330985984000000+-1*(x ** 26) / 403291461126605635584000000+0*(x ** 27) / 10888869450418352160768000000+1*(x ** 28) / 304888344611713860501504000000+0*(x ** 29) / 8841761993739701954543616000000+-1*(x ** 30) / 265252859812191058636308480000000+0*(x ** 31) / 8222838654177922817725562880000000+1*(x ** 32) / 263130836933693530167218012160000000+0*(x ** 33) / 8683317618811886495518194401280000000+-1*(x ** 34) / 295232799039604140847618609643520000000+0*(x ** 35) / 10333147966386144929666651337523200000000+1*(x ** 36) / 371993326789901217467999448150835200000000+0*(x ** 37) / 13763753091226345046315979581580902400000000+-1*(x ** 38) / 523022617466601111760007224100074291200000000+0*(x ** 39) / 20397882081197443358640281739902897356800000000+1*(x ** 40) / 815915283247897734345611269596115894272000000000+0*(x ** 41) / 33452526613163807108170062053440751665152000000000+-1*(x ** 42) / 1405006117752879898543142606244511569936384000000000+0*(x ** 43) / 60415263063373835637355132068513997507264512000000000+1*(x ** 44) / 2658271574788448768043625811014615890319638528000000000+0*(x ** 45) / 119622220865480194561963161495657715064383733760000000000+-1*(x ** 46) / 5502622159812088949850305428800254892961651752960000000000+0*(x ** 47) / 258623241511168180642964355153611979969197632389120000000000+1*(x ** 48) / 12413915592536072670862289047373375038521486354677760000000000+0*(x ** 49) / 608281864034267560872252163321295376887552831379210240000000000+-1*(x ** 50) / 30414093201713378043612608166064768844377641568960512000000000000+0*(x ** 51) / 1551118753287382280224243016469303211063259720016986112000000000000+1*(x ** 52) / 80658175170943878571660636856403766975289505440883277824000000000000+0*(x ** 53) / 4274883284060025564298013753389399649690343788366813724672000000000000+-1*(x ** 54) / 230843697339241380472092742683027581083278564571807941132288000000000000+0*(x ** 55) / 12696403353658275925965100847566516959580321051449436762275840000000000000+1*(x ** 56) / 710998587804863451854045647463724949736497978881168458687447040000000000000+0*(x ** 57) / 40526919504877216755680601905432322134980384796226602145184481280000000000000+-1*(x ** 58) / 2350561331282878571829474910515074683828862318181142924420699914240000000000000+0*(x ** 59) / 138683118545689835737939019720389406345902876772687432540821294940160000000000000+1*(x ** 60) / 8320987112741390144276341183223364380754172606361245952449277696409600000000000000+0*(x ** 61) / 507580213877224798800856812176625227226004528988036003099405939480985600000000000000+-1*(x ** 62) / 31469973260387937525653122354950764088012280797258232192163168247821107200000000000000+0*(x ** 63) / 1982608315404440064116146708361898137544773690227268628106279599612729753600000000000000+1*(x ** 64) / 126886932185884164103433389335161480802865516174545192198801894375214704230400000000000000+0*(x ** 65) / 8247650592082470666723170306785496252186258551345437492922123134388955774976000000000000000+-1*(x ** 66) / 544344939077443064003729240247842752644293064388798874532860126869671081148416000000000000000+0*(x ** 67) / 36471110918188685288249859096605464427167635314049524593701628500267962436943872000000000000000+1*(x ** 68) / 2480035542436830599600990418569171581047399201355367672371710738018221445712183296000000000000000+0*(x ** 69) / 171122452428141311372468338881272839092270544893520369393648040923257279754140647424000000000000000+-1*(x ** 70) / 11978571669969891796072783721689098736458938142546425857555362864628009582789845319680000000000000000+0*(x ** 71) / 850478588567862317521167644239926010288584608120796235886430763388588680378079017697280000000000000000+1*(x ** 72) / 61234458376886086861524070385274672740778091784697328983823014963978384987221689274204160000000000000000+0*(x ** 73) / 4470115461512684340891257138125051110076800700282905015819080092370422104067183317016903680000000000000000+-1*(x ** 74) / 330788544151938641225953028221253782145683251820934971170611926835411235700971565459250872320000000000000000+0*(x ** 75) / 24809140811395398091946477116594033660926243886570122837795894512655842677572867409443815424000000000000000000+1*(x ** 76) / 1885494701666050254987932260861146558230394535379329335672487982961844043495537923117729972224000000000000000000+0*(x ** 77) / 145183092028285869634070784086308284983740379224208358846781574688061991349156420080065207861248000000000000000000+-1*(x ** 78) / 11324281178206297831457521158732046228731749579488251990048962825668835325234200766245086213177344000000000000000000+0*(x ** 79) / 894618213078297528685144171539831652069808216779571907213868063227837990693501860533361810841010176000000000000000000+1*(x ** 80) / 71569457046263802294811533723186532165584657342365752577109445058227039255480148842668944867280814080000000000000000000+0*(x ** 81) / 5797126020747367985879734231578109105412357244731625958745865049716390179693892056256184534249745940480000000000000000000+-1*(x ** 82) / 475364333701284174842138206989404946643813294067993328617160934076743994734899148613007131808479167119360000000000000000000+0*(x ** 83) / 39455239697206586511897471180120610571436503407643446275224357528369751562996629334879591940103770870906880000000000000000000+1*(x ** 84) / 3314240134565353266999387579130131288000666286242049487118846032383059131291716864129885722968716753156177920000000000000000000+0*(x ** 85) / 281710411438055027694947944226061159480056634330574206405101912752560026159795933451040286452340924018275123200000000000000000000+-1*(x ** 86) / 24227095383672732381765523203441259715284870552429381750838764496720162249742450276789464634901319465571660595200000000000000000000+0*(x ** 87) / 2107757298379527717213600518699389595229783738061356212322972511214654115727593174080683423236414793504734471782400000000000000000000+1*(x ** 88) / 185482642257398439114796845645546284380220968949399346684421580986889562184028199319100141244804501828416633516851200000000000000000000+0*(x ** 89) / 16507955160908461081216919262453619309839666236496541854913520707833171034378509739399912570787600662729080382999756800000000000000000000+-1*(x ** 90) / 1485715964481761497309522733620825737885569961284688766942216863704985393094065876545992131370884059645617234469978112000000000000000000000+0*(x ** 91) / 135200152767840296255166568759495142147586866476906677791741734597153670771559994765685283954750449427751168336768008192000000000000000000000+1*(x ** 92) / 12438414054641307255475324325873553077577991715875414356840239582938137710983519518443046123837041347353107486982656753664000000000000000000000+0*(x ** 93) / 1156772507081641574759205162306240436214753229576413535186142281213246807121467315215203289516844845303838996289387078090752000000000000000000000+-1*(x ** 94) / 108736615665674308027365285256786601004186803580182872307497374434045199869417927630229109214583415458560865651202385340530688000000000000000000000+0*(x ** 95) / 10329978488239059262599702099394727095397746340117372869212250571234293987594703124871765375385424468563282236864226607350415360000000000000000000000+1*(x ** 96) / 991677934870949689209571401541893801158183648651267795444376054838492222809091499987689476037000748982075094738965754305639874560000000000000000000000+0*(x ** 97) / 96192759682482119853328425949563698712343813919172976158104477319333745612481875498805879175589072651261284189679678167647067832320000000000000000000000+-1*(x ** 98) / 9426890448883247745626185743057242473809693764078951663494238777294707070023223798882976159207729119823605850588608460429412647567360000000000000000000000+0*(x ** 99) / 933262154439441526816992388562667004907159682643816214685929638952175999932299156089414639761565182862536979208272237582511852109168640000000000000000000000
    ## original code 
    if x >= 0:
        x = x % (2*π)
    else:
        x = -((-x) % (2*π))
    result = 0
    sequence = [1, 0, -1, 0]
    for i in range(precision):
        result += sequence[i % 4] * (x ** i) / factorial(i)
    if result < -1:
        result = -1
    if result > 1:
        result = 1
    return result
       

# m to pixel
def pix(x):
    return x * 5000
## 1 m ≈ 5000 pix


def dis(vector):
    return (vector[0][0] ** 2 + vector[1][0] ** 2 + vector[2][0] ** 2) ** (1/2)

# transform the coordinate into real position vector format
def vector(x, y, z):
    return [
        [pix(x)],
        [pix(y)],
        [pix(z)],
        [1]
    ]

def vect(x, y, z):
    return [
        [x],
        [y],
        [z],
        [1]
    ]

def mat(li):
    return li

# transform a 1d list into matrix format
def to_matrix(x, y, lists):
    li = []
    for i in range(y):
        li.append(lists[i*x:(i+1)*x])
    return li


# useage: a, b = switchVar(a, b)
def switchVar(a, b):
    return b, a


# dot product between a vector and a matrix, return the product vector
def dot(a, b): ## assuming a 4x4 matrix and a 4x1 vector
    if(len(a[0]) != len(b)):
        if(len(b[0]) == len(a)):
            return dot(b, a)
        
    return [
        [a[0][0]*b[0][0] + a[0][1] * b[1][0] + a[0][2] * b[2][0] + a[0][3] * b[3][0]],
        [a[1][0]*b[0][0] + a[1][1] * b[1][0] + a[1][2] * b[2][0] + a[1][3] * b[3][0]],
        [a[2][0]*b[0][0] + a[2][1] * b[1][0] + a[2][2] * b[2][0] + a[2][3] * b[3][0]],
        [a[3][0]*b[0][0] + a[3][1] * b[1][0] + a[3][2] * b[2][0] + a[3][3] * b[3][0]]
    ]

    '''
    result = []
    for i in range(len(a)):
        result.append([])
        for j in range(len(b[0])):
            if(len(a[0]) != len(b)):
                if(len(b[0]) == len(a)):
                    return dot(b, a)
            result[i].append(0)
            for k in range(len(a[0])):
                result[i][j] += a[i][k] * b[k][j]
    return result
    '''

def subtract(a, b): ## assuming a 4x1 vector and a 4x1 vector
    return [
        [a[0][0] - b[0][0]],
        [a[1][0] - b[1][0]],
        [a[2][0] - b[2][0]],
        [1]
    ]




def make_shadow(color):
    return color


def sort_by_depth(item, layer):
    i = 0
    ## TODO: change to bubble sort
    while i != len(item):
        if(i != (len(item) - 1) and layer[i + 1] > layer[i]):
            item = item[:i] + item[i+1:] + [item[i]]
            layer = layer[:i] + layer[i+1:] + [layer[i]]
            i = 0
        else:
            i += 1
    return item, layer



def perspective_projection(mesh, pos, angle, absolute=False):
    n = screen_distance

    angle_a = angle[0]
    angle_c = angle[1]

    #a = -angle_a
    #c = -angle_c

    position_matrix = [
        [1, 0, 0, -pos[0][0]],
        [0, 1, 0, -pos[1][0]],
        [0, 0, 1, -pos[2][0]],
        [0, 0, 0, 1]
    ]
    '''
    rotation = [
        [cos(b) * cos(c), -cos(b)*sin(c), sin(b), 0],
        [cos(a) * sin(c) + cos(c)*sin(a)*sin(b), cos(a)*cos(c) - sin(a)*sin(b)*sin(c), -cos(b)*sin(a), 0],
        [sin(a)*sin(c) - cos(a)*cos(c)*sin(b), cos(c)*sin(a) + cos(a)*sin(b)*sin(c), cos(a)*cos(b), 0],
        [0, 0, 0, 1]
    ]
    '''


    rotate_matrix_x = [
        [1, 0, 0, 0],
        [0, cos(-angle_a), sin(-angle_a), 0],
        [0, -sin(-angle_a), cos(-angle_a), 0],
        [0, 0, 0, 1]
    ]

    rotate_matrix_z = [
        [cos(-angle_c), -sin(-angle_c), 0, 0],
        [sin(-angle_c), cos(-angle_c), 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 1]
    ]



    ## TODO: change the perspective matrix from absolute coordinates into relative coordinates
    perspective_matrix = [
        [n, 0, 0, 0],
        [0, n, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 1, n]
    ]
    ## TODO: multiply and simplify the matricies to optimize time complexity
    #matrix = dot(position_matrix, rotate_matrix_y)
    #matrix = dot(matrix, perspective_matrix)
    n_mesh = []
    for relation in mesh:
        n_relation = []
        for vertex in relation:
            if absolute:
                proj = dot(vertex, perspective_matrix)
                n_relation.append(proj)
                continue
            # proj = dot(matrix, vertex)
            
            ## transform
            visual = dot(position_matrix, vertex)
            ## apply rotations here
            visual = dot(visual, rotate_matrix_z)
            visual = dot(visual, rotate_matrix_x)
            #visual = dot(visual, rotate_matrix_y)
            #visual = dot(rotation, visual)

            proj = dot(perspective_matrix, visual)
            
            n_relation.append(proj)
        n_mesh.append(n_relation[:])
    return n_mesh


def Line_projection(mesh, view_vol=VIEW_VOL):
    li = []
    layer = []
    for face in mesh:
        try:
            if(abs(face[0][0][0] / face[0][3][0]) > view_vol[0] 
               or abs(face[0][1][0] / face[0][3][0]) > view_vol[1] 
               or abs(face[0][2][0]) > view_vol[2] or

               abs(face[1][0][0] / face[1][3][0]) > view_vol[0] 
               or abs(face[1][1][0] / face[1][3][0]) > view_vol[1] 
               or abs(face[1][2][0]) > view_vol[2] or

               abs(face[2][0][0] / face[2][3][0]) > view_vol[0] 
               or abs(face[2][1][0] / face[2][3][0]) > view_vol[1] 
               or abs(face[2][2][0]) > view_vol[2]):
                continue
            if(face[0][3][0] <= 0 or face[1][3][0] <= 0 or face[2][3][0] <= 0):
                continue
            display = [
                Line(Point(face[0][0][0] / face[0][3][0], face[0][1][0] / face[0][3][0]), 
                     Point(face[1][0][0] / face[1][3][0], face[1][1][0] / face[1][3][0])),

                Line(Point(face[0][0][0] / face[0][3][0], face[0][1][0] / face[0][3][0]), 
                     Point(face[2][0][0] / face[2][3][0], face[2][1][0] / face[2][3][0])),

                Line(Point(face[1][0][0] / face[1][3][0], face[1][1][0] / face[1][3][0]), 
                     Point(face[2][0][0] / face[2][3][0], face[2][1][0] / face[2][3][0]))
            ]
            li.extend(display)
            ## compare the depth information, saved for further use
            # layer.extend([
            #     (dis(face[0]) + dis(face[1])) / 2,
            #     (dis(face[0]) + dis(face[2])) / 2,
            #     (dis(face[1]) + dis(face[2])) / 2
            # ])
            ## compare using depth
            layer.extend([
                max([face[0][2][0], face[1][2][0]]),
                max([face[0][2][0], face[2][2][0]]),
                max(face[1][2][0], face[2][2][0])
            ])
        except ZeroDivisionError:
            continue
    return li, layer


def Face_projection(mesh, color_info=[], outline=False, view_vol=VIEW_VOL):
    try:
        if len(color_info) != len(mesh):
            raise NotImplementedError
        li = []
        layer = []
        for i, face in enumerate(mesh):
            try:
                if(abs(face[0][0][0] / face[0][3][0]) > view_vol[0] 
                or abs(face[0][1][0] / face[0][3][0]) > view_vol[1] 
                or abs(face[0][2][0]) > view_vol[2] or

                abs(face[1][0][0] / face[1][3][0]) > view_vol[0] 
                or abs(face[1][1][0] / face[1][3][0]) > view_vol[1] 
                or abs(face[1][2][0]) > view_vol[2] or

                abs(face[2][0][0] / face[2][3][0]) > view_vol[0] 
                or abs(face[2][1][0] / face[2][3][0]) > view_vol[1] 
                or abs(face[2][2][0]) > view_vol[2]):
                    continue
                if(face[0][3][0] <= 0 or face[1][3][0] <= 0 or face[2][3][0] <= 0):
                    continue
                li.append(Polygon(
                    Point(face[0][0][0] / face[0][3][0], face[0][1][0] / face[0][3][0]),
                    Point(face[1][0][0] / face[1][3][0], face[1][1][0] / face[1][3][0]),
                    Point(face[2][0][0] / face[2][3][0], face[2][1][0] / face[2][3][0])
                ))
                li[-1].setFill(make_shadow(color_info[i]))
                if not outline:
                    li[-1].setOutline("")
                else:
                    li[-1].setWidth(1)
                ## set overall depth as the distance (from the camera) of the midpoint of the face
                # layer.append((((face[0][0][0] + face[1][0][0] + face[2][0][0]) / 3) ** 2 + \
                #              ((face[0][1][0] + face[1][1][0] + face[2][1][0]) / 3) ** 2 + \
                #               ((face[0][2][0] + face[1][2][0] + face[2][2][0]) / 3) ** 2
                #              ) ** (1/2))
                ## set overall depth as the distance (from the camera) of the closest point of the face
                # layer.append(min([(face[0][0][0] ** 2 + face[0][1][0] ** 2 + face[0][2][0] ** 2) ** (1/2), 
                #                   (face[1][0][0] ** 2 + face[1][1][0] ** 2 + face[1][2][0] ** 2) ** (1/2),
                #                   (face[2][0][0] ** 2 + face[2][1][0] ** 2 + face[2][2][0] ** 2) ** (1/2)]))
                ## set overall depth as the depth of the deepest point of the face
                layer.append(max([face[0][2][0], face[1][2][0], face[2][2][0]]))
            except ZeroDivisionError:
                continue
        return li, layer
    except:
        return Line_projection(mesh)

real_FPS = FPS

keys = []
mouse_pos = None
mouse_click = None

god_mode = False


def tanh(z):
    if z == 0:
        return 0
    return (e**(z)-e**(-z))/(e**(z)+e**(-z))

# **************************************************** pages ********************************************************************


# --------------------------------------------------- universal element ---------------------------------------------------------
to_menu = [
    Image(Point(-WIDTH/2 + 50, HEIGHT/2 - 50), "img/Menu-button.png"),
    Image(Point(-WIDTH/2 + 50, HEIGHT/2 - 50), "img/Menu-button-hover.png"),
    Image(Point(-WIDTH/2 + 50, HEIGHT/2 - 50), "img/Menu-button-clicked.png"),
]
# --------------------------------------------------- universal element ---------------------------------------------------------


# ---------------------------------------------------- menu page ----------------------------------------------------------------
menu_page = [
    Image(Point(0, HEIGHT/3), "img/Title.png"),
    Image(Point(0, 25), "img/Icon.png")
]
menu_page_start_button = [
    Image(Point(0, -HEIGHT/4), "img/menu/Menu-StartButton.png"),
    Image(Point(0, -HEIGHT/4), "img/menu/Menu-StartButton-Hover.png"),
    Image(Point(0, -HEIGHT/4), "img/menu/Menu-StartButton-Clicked.png")
]
menu_page_instruct = [
    Image(Point(-WIDTH/7*2, -100), "img/menu/Menu-InstructionButton.png"),
    Image(Point(-WIDTH/7*2, -100), "img/menu/Menu-InstructionButton-Hover.png"),
    Image(Point(-WIDTH/7*2, -100), "img/menu/Menu-InstructionButton-Clicked.png")
]
menu_page_credit = [
    Image(Point(WIDTH/7*2, -100), "img/menu/Menu-CreditButton.png"),
    Image(Point(WIDTH/7*2, -100), "img/menu/Menu-CreditButton-Hover.png"),
    Image(Point(WIDTH/7*2, -100), "img/menu/Menu-CreditButton-Clicked.png")
]


def menu():

    layers = []

    mouse_pos = win.checkMouseHover()
    mouse_click = win.checkMouse()

    for item in menu_page:
        layers.append(item)

    # start button
    start = button_action(layers, mouse_pos, mouse_click,
                          menu_page_start_button, -217, 217, -142, -257)
    if start == 2:
        return levels()  # 'levels', layers

    # instructions button
    instruct = button_action(
        layers, mouse_pos, mouse_click, menu_page_instruct, -470, -272, -63.5, -138)
    if instruct == 2:
        return control()  # 'control', layers

    # credit button
    credit_but = button_action(
        layers, mouse_pos, mouse_click, menu_page_credit, 272, 472, -61, -137)
    if credit_but == 2:
        return credit()  # 'credit', layers

    return 'menu', layers
# ---------------------------------------------------- menu page ----------------------------------------------------------------


# ---------------------------------------------------- control page ----------------------------------------------------------------
control_page = [
    Image(Point(0, 0), "img/control/control-page.png")
]
control_page_rule = [
    Image(Point(518, -310), "img/control/rule-button.png"),
    Image(Point(518, -310), "img/control/rule-button-hover.png")
]


def control():

    layers = []

    mouse_pos = win.checkMouseHover()
    mouse_click = win.checkMouse()

    for item in control_page:
        layers.append(item)

    menu_but = button_action(
        layers, mouse_pos, mouse_click, to_menu, -632, -565, 378, 317)
    if menu_but == 2:
        return menu()  # 'menu', layers

    rule_but = button_action(
        layers, mouse_pos, mouse_click, control_page_rule, 433, 601, -256, -365)
    if rule_but == 2:
        return rule()  # 'rule', layers

    return 'control', layers
# ---------------------------------------------------- control page ----------------------------------------------------------------


# ---------------------------------------------------- rule page ----------------------------------------------------------------
rule_page = 0

rule_page_page = [
    Image(Point(0, 0), "img/rule/rule-page-0.png"),
    Image(Point(0, 0), "img/rule/rule-page-1.png"),
    Image(Point(0, 0), "img/rule/rule-page-2.png")
]

rule_next_page = [
    Image(Point(100, -300), "img/rule/rule-page-next.png"),
    Image(Point(100, -300), "img/rule/rule-page-next-hover.png")
]

rule_prev_page = [
    Image(Point(-100, -300), "img/rule/rule-page-prev.png"),
    Image(Point(-100, -300), "img/rule/rule-page-prev-hover.png")
]

rule_page_control = [
    Image(Point(518, -310), "img/rule/control-button.png"),
    Image(Point(518, -310), "img/rule/control-button-hover.png"),
]


def rule():
    global rule_page

    layers = []

    mouse_pos = win.checkMouseHover()
    mouse_click = win.checkMouse()

    layers.append(rule_page_page[rule_page])

    menu_but = button_action(
        layers, mouse_pos, mouse_click, to_menu, -632, -565, 378, 317)
    if menu_but == 2:
        rule_page = 0
        return menu()  # 'menu', layers

    control_but = button_action(
        layers, mouse_pos, mouse_click, rule_page_control, 424, 611, -257, -364)
    if control_but == 2:
        rule_page = 0
        return control()  # 'control', layers

    if(rule_page < (len(rule_page_page) - 1)):
        next = button_action(layers, mouse_pos, mouse_click,
                             rule_next_page, 23, 175, -260, -341)
        if(next == 2):
            rule_page += 1

    if(rule_page > 0):
        prev = button_action(layers, mouse_pos, mouse_click,
                             rule_prev_page, -175, -22, -260, -341)
        if(prev == 2):
            rule_page -= 1

    return 'rule', layers
# ---------------------------------------------------- rule page ----------------------------------------------------------------


# ---------------------------------------------------- credit page ----------------------------------------------------------------
# credit page: https://docs.google.com/drawings/d/1YWbp3tvRvkp1ECXJdOuE4rVaJgJXOQrz-JZHHicgHHY/edit
credit_page = [
    Image(Point(0, 0), "img/credits/credits-title.png")
]


def credit():
    layers = []

    mouse_pos = win.checkMouseHover()
    mouse_click = win.checkMouse()

    for item in credit_page:
        layers.append(item)

    menu_but = button_action(
        layers, mouse_pos, mouse_click, to_menu, -632, -565, 378, 317)
    if menu_but == 2:
        return menu()  # 'menu', layers

    return 'credit', layers

# ---------------------------------------------------- credit page ----------------------------------------------------------------


# ---------------------------------------------------- levels page ----------------------------------------------------------------
level = 1

level_1 = [
    Image(Point(-300, 0), "img/levels/L1.png"),
    Image(Point(-300, 0), "img/levels/L1-hover.png")
]
level_2 = [
    Image(Point(0, 0), "img/levels/L2.png"),
    Image(Point(0, 0), "img/levels/L2-hover.png")
]
level_3 = [
    Image(Point(300, 0), "img/levels/L3.png"),
    Image(Point(300, 0), "img/levels/L3-hover.png")
]


def levels():
    layers = []
    global level

    mouse_pos = win.checkMouseHover()
    mouse_click = win.checkMouse()

    menu_but = button_action(
        layers, mouse_pos, mouse_click, to_menu, -632, -565, 378, 317)
    if menu_but == 2:
        level = 1
        return menu()  # 'menu', layers

    level1 = button_action(layers, mouse_pos, mouse_click,
                           level_1, -371, -226, 71, -73)
    if level1 == 2:
        level = 1
        game_init()
        return level_info()  # 'level-info', layers

    level2 = button_action(layers, mouse_pos, mouse_click,
                           level_2, -72, 72, 71, -73)
    if level2 == 2:
        level = 2
        game_init()
        return level_info()  # 'level-info', layers

    level3 = button_action(layers, mouse_pos, mouse_click,
                           level_3, 226, 371, 71, -73)
    if level3 == 2:
        level = 3
        game_init()
        return level_info()  # 'level-info', layers

    return 'levels', layers

# ---------------------------------------------------- levels page ----------------------------------------------------------------


# ---------------------------------------------------- level-info page ----------------------------------------------------------------
level_icon = [
    None,
    Image(Point(-300, 0), "img/levels/L1.png"),
    Image(Point(-300, 0), "img/levels/L2.png"),
    Image(Point(-300, 0), "img/levels/L3.png")
]

f = open("score.txt", "r")
high_score = f.read().split(" ")
high_score.insert(0, None)

if(len(high_score) < 4):
    high_score = [
        None,
        "--:--:---",
        "--:--:---",
        "--:--:---"
    ]

back_to_levels = [
    Image(Point(-WIDTH/2 + 80, HEIGHT/2 - 70), "img/level-info/back.png"),
    Image(Point(-WIDTH/2 + 80, HEIGHT/2 - 70), "img/level-info/back-hover.png")
]

to_in_game = [
    Image(Point(300, -300), "img/level-info/Start.png"),
    Image(Point(300, -300), "img/level-info/Start-hover.png")
]

level_info_page = [
    Rectangle(Point(0, -HEIGHT/2), Point(WIDTH/2, HEIGHT/2)),
    Image(Point(300, 300), "img/level-info/Score.png")
]
level_info_page[0].setOutline("")
level_info_page[0].setFill("#d0d0d0")


def level_info():

    global level

    layers = []

    for item in level_info_page:
        layers.append(item)

    layers.append(level_icon[level])

    layers.append(Text(Point(300, 0), high_score[level]))
    layers[-1].setSize(36)

    mouse_pos = win.checkMouseHover()
    mouse_click = win.checkMouse()

    back_to_level = button_action(
        layers, mouse_pos, mouse_click, back_to_levels, -620, -517, 365, 292)
    if back_to_level == 2:
        return levels()  # 'levels', layers

    ingame = button_action(layers, mouse_pos, mouse_click,
                           to_in_game, 187, 412, -261, -337)
    if ingame == 2:
        return in_game()  # 'in-game', layers

    return 'level-info', layers
# ---------------------------------------------------- level-info page ----------------------------------------------------------------


# ---------------------------------------------------- in-game page ----------------------------------------------------------------

# ------------------------------------------------------------------- NOTE: Objects --------------------------------------------------------------------------
class Plane:  # NOTE
               # Shares angle with camera, only different in position.
               # Origin of the plane (pos) is also the global origin.
    def __init__(self, pos, normal):
        self.pos = pos[:]
        self.abs_pos = self.pos[:]
        self.color = [
            "#BDBDBD",
            "#9E9E9E",
            "#A0A0A0",
            "#A0A0A0",

            "#BDBDBD",
            "#BDBDBD",
            "#9E9E9E",
            "#9E9E9E",
            "#A0A0A0",
            "#A0A0A0",
            "#A0A0A0",
            "#A0A0A0",
            "#424242",
            "#424242",

            "#1E88E5",
            "#1E88E5",
            "#1E88E5",

            "#BDBDBD",
            "#BDBDBD",
            "#BDBDBD",

        ]
        self.speed = 10
        self.angle_z = 0
        self.angle_x = 0
        self.normal = normal[:]
        self.scale = 0.5
        scale = self.scale
        self.dimention = [250, 500, 100]  ## width, length, height

        epsilon = 0.1 ## avoid z-fighting
        
        self.abs_mesh = [
            ## tip
            [ ## top cover
                vect(40, 0+epsilon, 150),
                vect(-40, 0+epsilon, 150),
                vect(0, -25+epsilon, 250)
            ],
            [ ## bottom cover
                vect(40, -50-epsilon, 150),
                vect(-40, -50-epsilon, 150),
                vect(0, -25-epsilon, 250)
            ],
            [ ## right cover
                vect(40+epsilon, 0, 150),
                vect(40+epsilon, -50, 150),
                vect(0+epsilon, -25, 250)
            ],
            [ ## left cover
                vect(-40-epsilon, 0, 150),
                vect(-40-epsilon, -50, 150),
                vect(0-epsilon, -25, 250)
            ],

            ## body
            [ ## top cover 1
                vect(-50, 0, -250),
                vect(-50, 0, 150),
                vect(50, 0, 150)
            ],

            [ ## top cover 2
                vect(-50, 0, -250),
                vect(50, 0, -250),
                vect(50, 0, 150)
            ], 

            [ ## bottom cover 1
                vect(-50, -50-epsilon, -250),
                vect(-50, -50-epsilon, 150),
                vect(50, -50-epsilon, 150)
            ],

            [ ## bottom cover 2
                vect(-50, -50-epsilon, -250),
                vect(50, -50-epsilon, -250),
                vect(50, -50-epsilon, 150)
            ], 

            [ ## left cover 1
                vect(-50-epsilon, 0, -250),
                vect(-50-epsilon, -50, -250),
                vect(-50-epsilon, -50, 150+epsilon)
            ], 

            [ ## left cover 2
                vect(-50-epsilon, 0, -250),
                vect(-50-epsilon, 0, 150+epsilon),
                vect(-50-epsilon, -50, 150+epsilon)
            ],

            [ ## right cover 1
                vect(50+epsilon, 0, -250),
                vect(50+epsilon, -50, -250),
                vect(50+epsilon, -50, 150+epsilon)
            ],

            [ ## right cover 2
                vect(50+epsilon, 0, -250),
                vect(50+epsilon, 0, 150+epsilon),
                vect(50+epsilon, -50, 150+epsilon)
            ],

            [ ## back cover 1
                vect(-50, 0, -250-epsilon),
                vect(-50, -50, -250-epsilon),
                vect(50, 0, -250-epsilon)
            ],

            [ ## back cover 2
                vect(50, 0, -250-epsilon),
                vect(50, -50, -250-epsilon),
                vect(-50, -50, -250-epsilon)
            ],


            ## cockpit
            [ ## wind shield
                vect(-40, 0+epsilon, 150+epsilon),
                vect(40, 0+epsilon, 150+epsilon),
                vect(0, 25+epsilon, 100+epsilon)
            ],

            [ ## left window
                vect(-40-epsilon, 0+epsilon, 150-epsilon),
                vect(0-epsilon, 25+epsilon, 100-epsilon),
                vect(0-epsilon, 0+epsilon, 0-epsilon)
            ],

            [ ## right window
                vect(40+epsilon, 0+epsilon, 150-epsilon),
                vect(0+epsilon, 25+epsilon, 100-epsilon),
                vect(0+epsilon, 0+epsilon, 0-epsilon)
            ],

            ## Wings
            [ ## left wing
                vect(-50-epsilon, -25-epsilon, 170),
                vect(-50-epsilon, -25-epsilon, -225),
                vect(-200-epsilon, -25-epsilon, -225) 
            ],
            
            [ ## right wing
                vect(50+epsilon, -25-epsilon, 170),
                vect(50+epsilon, -25-epsilon, -225),
                vect(200+epsilon, -25-epsilon, -225)
            ],

            [ ## vertical wing
                vect(0, 0+epsilon, -100),
                vect(0, 0+epsilon, -240),
                vect(0, 80+epsilon, -240)
            ]


        ]
        self.mesh = []
        for i in range(len(self.abs_mesh)):
            self.mesh.append([])
            for j in range(3):
                self.mesh[i].append(vect(0, 0, 0))

        self.hitbox = ["sphere", (self.dimention[0] + self.dimention[1] + self.dimention[2])/12]  ## hitbox type, radius

    def update(self):

        # movement
        forward = mat([
            [1, 0, 0, 0],
            [0, 1, 0, self.normal[2][1][0] * self._speed],
            [0, 0, 1, self.normal[2][2][0] * self._speed],
            [0, 0, 0, 1]
        ])  # straight
        side = mat([
            [1, 0, 0, self.normal[0][0][0] * self.angle_z * -10000 / real_FPS],
            [0, 1, 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 1]
        ])  # sideway

        # rotate
        matrix_x = mat([
            [1, 0, 0, 0],
            [0, cos(self.angle_x), sin(self.angle_x), 0],
            [0, -sin(self.angle_x), cos(self.angle_x), 0],
            [0, 0, 0, 1]
        ])
        matrix_z = mat([
            [cos(self.angle_z), -sin(self.angle_z), 0, 0],
            [sin(self.angle_z), cos(self.angle_z), 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 1]
        ])

        self.pos = dot(forward, self.pos)
        self.pos = dot(side, self.pos)

        position = mat([
            [1, 0, 0, self.pos[0][0]],
            [0, 1, 0, self.pos[1][0]],
            [0, 0, 1, self.pos[2][0]],
            [0, 0, 0, 1]
        ])

        self.normal = [vect(1, 0, 0), vect(0, 1, 0), vect(0, 0, 1)]

        # y                   * does not matter
        self.normal[1] = dot(matrix_z, vect(0, 1, 0))
        self.normal[2] = dot(matrix_x, vect(0, 0, 1))  # z

        for i, face in enumerate(self.abs_mesh):
            for j, vertex in enumerate(face):
                self.mesh[i][j] = dot(matrix_z, self.abs_mesh[i][j])
                self.mesh[i][j] = dot(matrix_x, self.mesh[i][j])
                self.mesh[i][j] = dot(position, self.mesh[i][j])

        return self.pos[:]

    def rotate(self, z, x):
        self.angle_x += x
        self.angle_z += z

    def set_speed(self, speed):
        self._speed = speed

    def set_pos(self, pos):
        self.pos = pos

    def set_angle(self, z, x):
        self.angle_x = x
        self.angle_z = z


class Object:
    def __init__(self, pos, size=100):
        self.pos = pos[:]
        x = self.pos[0][0]
        y = self.pos[1][0]
        z = self.pos[2][0]

        self.size = size

        self.position = mat([
            [1, 0, 0, x],
            [0, 1, 0, y],
            [0, 0, 1, z],
            [0, 0, 0, 1]
        ])

        self.angle_x = (random.random()-0.5) * 4 * π
        self.angle_y = (random.random()-0.5) * 4 * π
        self.angle_z = (random.random()-0.5) * 4 * π

        self.x_speed = (random.random()-0.5) * 2 * π
        self.y_speed = (random.random()-0.5) * 2 * π
        self.z_speed = (random.random()-0.5) * 2 * π



        v1 = vect(x, y - (8/9)**(1/2)*size, z + size/3)
        v2 = vect(x + (2/3)**(1/2)*size, y + (2/9)**(1/2)*size, z + size/3)
        v3 = vect(x - (2/3)**(1/2)*size, y + (2/9)**(1/2)*size, z + size/3)
        v4 = vect(x, y, z - size)

        self.mesh = [
            [v1, v2, v3],
            [v1, v2, v4],
            [v1, v3, v4],
            [v2, v3, v4]
        ]

        v1 = vect(0, -(8/9)**(1/2)*size, size/3)
        v2 = vect((2/3)**(1/2)*size, (2/9)**(1/2)*size, size/3)
        v3 = vect(-(2/3)**(1/2)*size, (2/9)**(1/2)*size, size/3)
        v4 = vect(0, 0, -size)

        self.abs_mesh = [
            [v1, v2, v3],
            [v1, v2, v4],
            [v1, v3, v4],
            [v2, v3, v4]
        ]
        
        self.color = [
            color_rgb(200, 200, 200),
            color_rgb(190, 190, 190),
            color_rgb(180, 180, 180),
            color_rgb(170, 170, 170)
        ]

        self.dimention = [size*2, size*2, size*2]  ## width, length, height

        self.hitbox = ["sphere", size*3/4]  ## hitbox type, radius

    def update(self):
        self.angle_x += self.x_speed / FPS
        self.angle_y += self.y_speed / FPS
        self.angle_z += self.z_speed / FPS
        matrix_x = mat([
            [1, 0, 0, 0],
            [0, cos(self.angle_x), sin(self.angle_x), 0],
            [0, -sin(self.angle_x), cos(self.angle_x), 0],
            [0, 0, 0, 1]
        ])
        matrix_y = mat([
            [cos(self.angle_y), 0, -sin(self.angle_y), 0],
            [0, 1, 0, 0],
            [sin(self.angle_y), 0, cos(self.angle_y), 0],
            [0, 0, 0, 1]
        ])
        matrix_z = mat([
            [cos(self.angle_z), -sin(self.angle_z), 0, 0],
            [sin(self.angle_z), cos(self.angle_z), 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 1]
        ])

        for i, face in enumerate(self.mesh):
            for j, vertex in enumerate(face):
                self.mesh[i][j] = dot(matrix_x, self.abs_mesh[i][j])
                self.mesh[i][j] = dot(matrix_y, self.mesh[i][j])
                self.mesh[i][j] = dot(matrix_z, self.mesh[i][j])
                self.mesh[i][j] = dot(self.position, self.mesh[i][j])
    def reset(self):
        size = self.size
        x = self.pos[0][0]
        y = self.pos[1][0]
        z = self.pos[2][0]
        v1 = vect(x, y - (8/9)**(1/2)*size, z + size/3)
        v2 = vect(x + (2/3)**(1/2)*size, y + (2/9)**(1/2)*size, z + size/3)
        v3 = vect(x - (2/3)**(1/2)*size, y + (2/9)**(1/2)*size, z + size/3)
        v4 = vect(x, y, z - size)
        self.angle_x = (random.random()-0.5) * 4 * π
        self.angle_y = (random.random()-0.5) * 4 * π
        self.angle_z = (random.random()-0.5) * 4 * π

        self.x_speed = (random.random()-0.5) * 2 * π
        self.y_speed = (random.random()-0.5) * 2 * π
        self.z_speed = (random.random()-0.5) * 2 * π


        self.mesh = [
            [v1, v2, v3],
            [v1, v2, v4],
            [v1, v3, v4],
            [v2, v3, v4]
        ]

        v1 = vect(0, -(8/9)**(1/2)*size, size/3)
        v2 = vect((2/3)**(1/2)*size, (2/9)**(1/2)*size, size/3)
        v3 = vect(-(2/3)**(1/2)*size, (2/9)**(1/2)*size, size/3)
        v4 = vect(0, 0, -size)

        self.abs_mesh = [
            [v1, v2, v3],
            [v1, v2, v4],
            [v1, v3, v4],
            [v2, v3, v4]
        ]
        


def collide(obj1, obj2):
    return (obj1.hitbox[1] + obj2.hitbox[1]) > dis(subtract(obj1.pos, obj2.pos))

# ------------------------------------------------------------------- NOTE: Objects --------------------------------------------------------------------------


maps = [None, [], [], []]
rocks = [None, [], [], []]

TUNNEL_WIDTH = [None, 20000, 10000, 2000]
TUNNEL_HEIGHT = [None, 20000, 5000, 2000]
DISTANCE = [None, 1000000, 2000000, 2000000]
TUNNEL_DENSITY = [None, 0.5, 0.5, 0.5]  # per 10000 pixels

OBJECT_SIZE = [None, 10000, 3000, 1000]
OBJECT_DENSITY = [None, 0.05, 0.1, 0.1]  # per 10000 pixels
START_DIS = [None, 1, 5, 5]  # for # of objects

for level_index in range(1, 4):
    tunnel_count = int(DISTANCE[level_index]*TUNNEL_DENSITY[level_index]/10000)
    for i in range(START_DIS[level_index], int(DISTANCE[level_index]*OBJECT_DENSITY[level_index]/10000)):
        a_object = Object(
            [
                [
                    random.randint(-TUNNEL_WIDTH[level_index]+OBJECT_SIZE[level_index],
                                   TUNNEL_WIDTH[level_index]-OBJECT_SIZE[level_index])
                ],
                [
                    random.randint(-TUNNEL_HEIGHT[level_index]+OBJECT_SIZE[level_index],
                                   TUNNEL_HEIGHT[level_index]-OBJECT_SIZE[level_index])
                ],
                [
                    (i) * DISTANCE[level_index]/(DISTANCE[level_index]
                     * OBJECT_DENSITY[level_index]/10000)
                ]
            ], size=OBJECT_SIZE[level_index])
        #maps[level_index].append([a_object.mesh, a_object.color])
        rocks[level_index].append(a_object)
    density = tunnel_count
    width = TUNNEL_WIDTH[level_index]
    height = TUNNEL_HEIGHT[level_index]
    distance = DISTANCE[level_index]
    for i in range(tunnel_count):
        wall = [
            [
                vect(width, height, i*distance/density),
                vect(width, height, (i+1)*distance/density),
                vect(width, -height, (i+1)*distance/density)
            ],
            [
                vect(width, height, i*distance/density),
                vect(width, -height, i*distance/density),
                vect(width, -height, (i+1)*distance/density)
            ],  # right wall

            [
                vect(-width, height, i*distance/density),
                vect(-width, height, (i+1)*distance/density),
                vect(-width, -height, (i+1)*distance/density)
            ],
            [
                vect(-width, height, i*distance/density),
                vect(-width, -height, i*distance/density),
                vect(-width, -height, (i+1)*distance/density)
            ],  # left wall

            [
                vect(-width, height, i*distance/density),
                vect(width, height, i*distance/density),
                vect(-width, height, (i+1)*distance/density)
            ],
            [
                vect(width, height, i*distance/density),
                vect(-width, height, (i+1)*distance/density),
                vect(width, height, (i+1)*distance/density)
            ],  # top wall

            [
                vect(-width, -height, i*distance/density),
                vect(width, -height, i*distance/density),
                vect(-width, -height, (i+1)*distance/density)
            ],
            [
                vect(width, -height, i*distance/density),
                vect(-width, -height, (i+1)*distance/density),
                vect(width, -height, (i+1)*distance/density)
            ],  # bottom wall
        ]

        wall_color = [
            "#555555",
            "#555555",
            "#555555",
            "#555555",
            "#555555",
            "#555555",
            "#555555",
            "#555555"
        ]
        maps[level_index].append([wall, wall_color])
    maps[level_index].append([
        [
            [
                vect(-width, -height, distance),
                vect(-width, height, distance),
                vect(width, height, distance)
            ],
            [
                vect(width, height, distance),
                vect(width, -height, distance),
                vect(-width, -height, distance)
            ]
        ],
        [
            '#00ff00',
            '#00ff00'
        ]
    ])


reverse_yield = True

pos = vect(0, 0, 0)
pos_normal = [vect(1, 0, 0), vect(0, 1, 0), vect(0, 0, 1)]  # right, up, front
angle = [0, 0]

YIELD_SPEED = 0.1*π  # per second @ min speed
ROW_SPEED = 1*π  # per second

INIT_SPEED = 1000

speed = INIT_SPEED
yield_angle = 0
row_angle = 0

lap_time = 0
new_high = False

player_plane = Plane(pos, pos_normal)


def game_init():
    global player_plane
    global maps

    global pos
    global pos_normal
    # angle: [yield, row]
    # use ZX rotation

    global speed
    global angle
    global yield_angle
    global row_angle

    global lap_time

    global god_mode

    for obj in rocks[level]:
        obj.reset()

    pos = vect(0, 0, 0)
    pos_normal = [vect(1, 0, 0), vect(0, 1, 0), vect(0, 0, 1)]  # right, up, front
    speed = INIT_SPEED
    angle = [0, 0]

    player_plane = Plane(pos, pos_normal)

    yield_angle = 0
    row_angle = 0

    lap_time = 0

    god_mode = False

    set_screen_dis(2500)


def in_game():
    global new_high
    global level
    global maps
    map = maps[level]
    new_high = False

    global pos
    global pos_normal
    # angle: [yield, row]
    # use ZX rotation

    global speed
    global angle
    global reverse_yield

    global yield_angle
    global row_angle

    global lap_time

    global god_mode

    min_screen_dis = 400
    max_screen_dis = 2500  # normal

    items = []
    layers = []

    final_layers = [Rectangle(Point(-WIDTH/2, HEIGHT/2), Point(WIDTH/2, -HEIGHT/2))]

    final_layers[0].setFill("#555555")


    keys = win.checkAllKeys()
    if('m' in keys):
        return pause()  # 'level-info', items

    yield_rate = 1/(speed-INIT_SPEED+1)**(1/16)/real_FPS

    if(not(('w' in keys) or ('s' in keys))):
        yield_angle += tanh(-yield_angle)*YIELD_SPEED
    if('w' in keys):
        if(reverse_yield):
            yield_angle += -YIELD_SPEED*yield_rate - max(0, tanh(yield_angle)*YIELD_SPEED)
        else:
            yield_angle += YIELD_SPEED*yield_rate + max(0, tanh(-yield_angle)*YIELD_SPEED)
        speed -= 10/real_FPS
    if('s' in keys):
        if(reverse_yield):
            yield_angle += YIELD_SPEED*yield_rate + max(0, tanh(-yield_angle)*YIELD_SPEED)
        else:
            yield_angle += -YIELD_SPEED*yield_rate - max(0, tanh(yield_angle)*YIELD_SPEED)
        speed -= 10/real_FPS

    if(not(('a' in keys) or ('d' in keys))):
        row_angle += tanh(-row_angle)*ROW_SPEED/real_FPS
    if('a' in keys):
        row_angle += ROW_SPEED/real_FPS
    if('d' in keys):
        row_angle += -ROW_SPEED/real_FPS
    if('space' in keys):
        acc = 2000/real_FPS
        set_screen_dis(get_screen_dis()/1.1 * (get_screen_dis() > min_screen_dis) +
                       min_screen_dis * (get_screen_dis() <= min_screen_dis))
        speed += acc
    else:
        speed -= (speed-INIT_SPEED+1)**2/real_FPS**2/1000
        set_screen_dis(get_screen_dis()*1.05 * (get_screen_dis() < max_screen_dis) +
                       max_screen_dis * (get_screen_dis() >= max_screen_dis))
        if speed < INIT_SPEED:
            speed = INIT_SPEED

    if('t' in keys and 'h' in keys and 'e' in keys and 'a' in keys):
        god_mode = not god_mode
        return pause()
    if(row_angle > π/2):
        row_angle = π/2
    if(row_angle < -π/2):
        row_angle = -π/2
    if(yield_angle > π/2):
        yield_angle = π/2
    if(yield_angle < -π/2):
        yield_angle = -π/2

    player_plane.set_speed(speed*100/real_FPS)
    player_plane.set_angle(row_angle, yield_angle)
    pos = player_plane.update()
    
    pos = dot(mat([
        [1, 0, 0, 0],
        [0, 1, 0, 200],
        [0, 0, 1, (-max_screen_dis+get_screen_dis())*0.5],
        [0, 0, 0, 1]
    ]), pos)

    if(pos[2][0] >= DISTANCE[level]):
        return finish()

    for obj in map:
        n_obj = perspective_projection(obj[0], pos, angle)
        item, layer = Face_projection(n_obj, obj[1], outline=1)
        items.extend(item)
        layers.extend(layer)
    for obj in rocks[level]:
        if obj.pos[2][0] <= pos[2][0] + VIEW_VOL[2]:
            obj.update()
        if(collide(obj, player_plane) or not((-TUNNEL_HEIGHT[level] + player_plane.hitbox[1] <= pos[1][0] <= TUNNEL_HEIGHT[level] - player_plane.hitbox[1]) and (-TUNNEL_WIDTH[level] + player_plane.hitbox[1] <= pos[0][0] <= TUNNEL_WIDTH[level] - player_plane.hitbox[1]))):
            if(not god_mode):
                return game_over()
        n_obj = perspective_projection(obj.mesh, pos, angle)
        item, layer = Face_projection(n_obj, obj.color, outline=False)
        items.extend(item)
        layers.extend(layer)
    n_obj = perspective_projection(player_plane.mesh, pos, angle, absolute=False)
    item, layer = Face_projection(n_obj, player_plane.color, outline=True)
    items.extend(item)
    layers.extend(layer)
    items, layers = sort_by_depth(items, layers)

    items.append(Text(Point(WIDTH/2 - 50, -HEIGHT/2 + 50), str(seconds_to_str(lap_time))))

    lap_time += 1/real_FPS

    final_layers.extend(items)

    return 'in-game', final_layers
# ---------------------------------------------------- in-game page ----------------------------------------------------------------


# ---------------------------------------------------- pause page ----------------------------------------------------------------
pause_screen = Image(Point(0, 0), "img/pause/Pause-Screen.png")

retry_button = [
    Image(Point(-200, -100), "img/pause/Retry-Button.png"),
    Image(Point(-200, -100), "img/pause/Retry-Button-Hover.png")
]

resume_button = [
    Image(Point(200, -100), "img/pause/Resume-Button.png"),
    Image(Point(200, -100), "img/pause/Resume-Button-Hover.png")
]

def pause():
    layers = []

    mouse_pos = win.checkMouseHover()
    mouse_click = win.checkMouse()

    layers.append(pause_screen)

    retry_but = button_action(layers, mouse_pos, mouse_click, retry_button, -308, -90, -70, -132)
    if retry_but == 2:
        game_init()
        return level_info()
    
    resume_but = button_action(layers, mouse_pos, mouse_click, resume_button, 90, 308, -70, -132)
    if resume_but == 2:
        return in_game()
    
    menu_but = button_action(layers, mouse_pos, mouse_click, to_menu, -632, -565, 378, 317)
    if menu_but == 2:
        game_init()
        return menu()
    
    return 'pause', layers

# ---------------------------------------------------- pause page ----------------------------------------------------------------


# ---------------------------------------------------- game-over page ----------------------------------------------------------------

game_over_screen = Image(Point(0, 0), "img/game-over/Game-Over-Screen.png")

exit_button = [
    Image(Point(0, -200), "img/game-over/Exit-Button.png"),
    Image(Point(0, -200), "img/game-over/Exit-Button-Hover.png")
]

def game_over():

    mouse_pos = win.checkMouseHover()
    mouse_click = win.checkMouse()

    layers = [game_over_screen]

    menu_but = button_action(layers, mouse_pos, mouse_click, to_menu, -632, -565, 378, 317)
    if menu_but == 2:
        game_init()
        return menu()
    
    exit_but = button_action(layers, mouse_pos, mouse_click, exit_button, -126, 126, -162, -239)
    if exit_but == 2:
        game_init()
        return level_info()

    return 'game-over', layers
# ---------------------------------------------------- game-over page ----------------------------------------------------------------


# ---------------------------------------------------- finish page ----------------------------------------------------------------

finish_screen = Image(Point(0, 0), "img/finish/finish-screen.png")
high_score_text = Text(Point(100, -50), "New Record!")
high_score_text.setSize(30)
high_score_text.setTextColor('#ff0000')
time_text = Text(Point(0, 0), "--:--:---")
time_text.setSize(36)

def finish():
    global high_score
    global lap_time
    global new_high

    mouse_pos = win.checkMouseHover()
    mouse_click = win.checkMouse()

    layers = [finish_screen]

    if(seconds(high_score[level]) > lap_time):
        high_score[level] = seconds_to_str(lap_time)
        new_high = True

    if(new_high):
        f = open("score.txt", "w")
        f.write(" ".join(high_score[1:]))
        f.close()
        layers.append(high_score_text)
    time_text.setText(seconds_to_str(lap_time))
    layers.append(time_text)

    menu_but = button_action(layers, mouse_pos, mouse_click, to_menu, -632, -565, 378, 317)
    if menu_but == 2:
        game_init()
        return menu()
    
    exit_but = button_action(layers, mouse_pos, mouse_click, exit_button, -126, 126, -162, -239)
    if exit_but == 2:
        game_init()
        return level_info()

    return 'finish', layers
# ---------------------------------------------------- finish page ----------------------------------------------------------------


def button_action(layers, mouse_pos, mouse_click, button, x_left, x_right, y_top, y_bottom):
    if mouse_pos != None:
        if(x_left < mouse_pos.x < x_right) and (y_top > mouse_pos.y > y_bottom):
            if mouse_click == None:
                layers.append(button[1])
                return 1
            else:
                # layers.append(button[2])
                return 2
        else:
            layers.append(button[0])
            return 0
    else:
        layers.append(button[0])
        return 0
    
def seconds(my_time):
    '''
    high_score = [
        None,
        "--:--:---",
        "--:--:---",
        "--:--:---"
    ]
    '''
    if my_time == "--:--:---":
        return 9999999999999999
    return int(my_time[0:2]) * 60 + int(my_time[3:5]) + int(my_time[6:]) * 0.001

def seconds_to_str(my_time):
    minute = str(int(my_time / 60))
    sec = str(int(my_time - int(my_time / 60)))
    mil_sec = str(int((my_time - int(my_time)) * 1000))
    if len(minute) < 2:
        minute = '0' * (2 - len(minute)) + minute
    if len(minute) > 2:
        minute = '99'
    if len(sec) < 2:
        sec = '0' * (2 - len(sec)) + sec
    if len(mil_sec) < 3:
        mil_sec = '0' * (3 - len(mil_sec)) + mil_sec
    return minute + ':' + sec + ':' + mil_sec

# -------------------------------------------------------- init ---------------------------------------------------------------


win = GraphWin("Dash", WIDTH, HEIGHT, autoflush=False)
win.setCoords(-WIDTH/2, -HEIGHT/2, WIDTH/2, HEIGHT/2)
win.setBackground("#ececec")

items = []
layers = []
pre_GS = ''
GS = 'menu'

Dashboard = Text(Point(-WIDTH/2 + 100, HEIGHT/2 - 100), "FPS: ")
Dashboard.setSize(12)
Dashboard.draw(win)

# -------------------------------------------------------- init ---------------------------------------------------------------
sys.stdout.write("\n\n")
# -------------------------------------------------------- Game loop ----------------------------------------------------------

while True:

    if win.isClosed():
        break

    keys = win.checkAllKeys()
    mouse_pos = win.checkMouseHover()

    # if 'q' in keys:
    # win.close()
    # continue

    items = layers[:]

    pre_GS = GS

    if GS == 'menu':
        GS, layers = menu()
    elif GS == 'control':
        GS, layers = control()
    elif GS == 'rule':
        GS, layers = rule()
    elif GS == 'credit':
        GS, layers = credit()
    elif GS == 'in-game':
        GS, layers = in_game()
    elif GS == 'levels':
        GS, layers = levels()
    elif GS == 'pause':
        GS, layers = pause()
    elif GS == 'level-info':
        GS, layers = level_info()
    elif GS == 'game-over':
        GS, layers = game_over()
    elif GS == 'finish':
        GS, layers = finish()
    else:
        break

    if pre_GS != GS:

        # end
        black_screen = Rectangle(
            Point(WIDTH, HEIGHT), Point(WIDTH, HEIGHT))
        black_screen.setFill("#000000")
        x = WIDTH/2
        dx = 0
        d2x = -5
        if win.isClosed():
            break
        black_screen.draw(win)
        update()

        while True:

            if x <= -WIDTH/2:
                break

            # d2x = -1
            x += dx
            dx += d2x
            black_screen.undraw()
            black_screen = Rectangle(
                Point(x, -HEIGHT), Point(WIDTH, HEIGHT))
            black_screen.setFill("#000000")
            if win.isClosed():
                break
            black_screen.draw(win)
            update(FPS)

        if win.isClosed():
            break

        for item in items:
            item.undraw()
        black_screen.undraw()

        # start
        for item in layers:
            item.draw(win)
        black_screen = Rectangle(
            Point(-WIDTH, -HEIGHT), Point(WIDTH, HEIGHT))
        black_screen.setFill("#000000")
        x = WIDTH/2
        dx = -WIDTH/5
        d2x = 28.888
        if win.isClosed():
            break
        black_screen.draw(win)
        update()

        while True:
            
            if win.isClosed():
                break

            if x <= -WIDTH/2:
                black_screen.undraw()
                break

            # d2x = -1
            x += dx
            dx += d2x
            black_screen.undraw()
            black_screen = Rectangle(Point(-WIDTH, -HEIGHT), Point(x, HEIGHT))
            black_screen.setFill("#000000")
            black_screen.draw(win)
            update(FPS)

    ## if items == layers:
    ##     continue
    # display
    for item in items:
        item.undraw()
    for item in layers:
        item.undraw()
    if win.isClosed():
        break
    for item in layers:
        item.draw(win)

    Dashboard.setText("FPS: " + str(round(real_FPS, 2)))
    Dashboard.undraw()
    if win.isClosed():
        break
    Dashboard.draw(win)

    real_FPS = update(FPS)
    real_FPS = FPS

print("\nsupercalifragilisticexpialidocious\n")
